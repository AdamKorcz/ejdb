# JQP grammar

%prefix "jqp"

%value "JPQAUX *"

%auxil "void *"

%header {
  #include "jql.h"
  #include <errno.h>
  #include <setjmp.h>
  
  typedef struct _JPQAUX {
    int pos;
    int line;
    int col;
    iwrc rc;
    jmp_buf fatal_jmp;
    const char *buf;
  } JPQAUX;
}

%source {
  
  static int _jqp_get_char(JPQAUX *aux) {
    if (aux->rc || *(aux->buf + aux->pos) == '\0') {
      return -1;
    } else {
      char ch = *(aux->buf + aux->pos++);
      if (ch == '\n') {
        ++aux->line;
        aux->col = 1; 
      }
      ++aux->col;
      return ch;
    }
  }

  static void _jqp_error(JPQAUX *aux) {
    if (!aux->rc) {
      aux->rc = JQL_ERROR_QUERY_PARSE;
    }
    if (aux->fatal_jmp) {
      longjmp(aux->fatal_jmp, 1);
    }
  }
  
  static void *_jqp_malloc(JPQAUX *aux, size_t size) {
    void *ret = malloc(size);
    if (!ret) {
      aux->rc = iwrc_set_errno(IW_ERROR_ALLOC, errno);
      if (aux->fatal_jmp) {
        longjmp(aux->fatal_jmp, 1);
      } else {
        fprintf(stderr, "Out of memory\n");
        exit(1);
      }
    }
    return ret;
  }
  
  static void *_jqp_realloc(JPQAUX *aux, void *ptr, size_t size) {
    void *ret = realloc(ptr, size);
    if (!ret) {
      aux->rc = iwrc_set_errno(IW_ERROR_ALLOC, errno);
      if (aux->fatal_jmp) {
        longjmp(aux->fatal_jmp, 1);
      } else {
        fprintf(stderr, "Out of memory\n");
        exit(1);
      }
    }
    return ret;
  }
  
  #define PCC_GETCHAR(auxil) _jqp_get_char(auxil)
  #define PCC_ERROR(auxil) _jqp_error(auxil)
  #define PCC_MALLOC(auxil, size) _jqp_malloc(auxil, size)
  #define PCC_REALLOC(auxil, ptr, size) _jqp_realloc(auxil, ptr, size)
}

QUERY <- FILTER (__ FILTERJOIN __ FILTER)* _ EOF

FILTER <- '/' NODE ('/' NODE)*

FILTERJOIN <- "and" / "or" / "not"

# Node
NODE <- STRN / OPNODE / CHP+

OPNODE <- '[' _ OPLEFT _ OP _ OPRIGHT _ ']'

OPLEFT <- STRN / NODELEFT / CHP+

NODELEFT <- '[' _ (STRN / CHP+) _ OP _ OPRIGHT _ ']'

OPRIGHT <- PLACEHOLDER / VALJ

PLACEHOLDER <- ':' ('?'? / [A-Za-z] [A-Za-z0-9]*)

# Node operation
OP <-  "and"
       "or"
        / ("not" __)? ("like" / "in" / "re" )
        / ">="
        / "<="
        / ('!' _)? '='
        / '>'
        / '<'
        / "not"

# Node string
STRN <- '"' CHJ+ '"'

# JSON object
OBJJ <- '[' _ (PAIRJ (_ ',' _ PAIRJ)* )? _ ']'

# JSON array
ARRJ <- '[' _ (VALJ (_ ',' _ VALJ)* )? _ ']'

# JSON object pair
PAIRJ <- STRJ _ ':' _ STRJ

# JSON value
VALJ <-   STRJ
        / NUMJ
        / OBJJ
        / ARRJ
        / "true"
        / "false"
        / "null"

# JSON string
STRJ <- '"' CHJ* '"'

# JSON char
CHJ <- '\\' '"'
      / '\\' '\\'
      / '\\' [bfnrt]
      / '\\' 'u' HEX HEX HEX HEX
      / (!'"' .)

# Property char
CHP <- '\\' '\\'
      / '\\' [bfnrt]
      / '\\' 'u' HEX HEX HEX HEX
      / ([^=><!"\t\n\r ] .)

NUMJ <- '-'? NUMI NUMF? NUME?

NUMI <- '0' / [1-9] [0-9]*

NUMF <- '.' [0-9]+

NUME <-  [eE] [+-]? DIGIT+

HEX <- [0-9A-Fa-f]

DIGIT <- [0-9]

_ <- [\t\n\r ]*

__ <- [\t\n\r ]+

EOF <- !.

%%
