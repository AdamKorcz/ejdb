# JQP grammar

%prefix "jqp"

%value "JPQDATA *"

%auxil "JPQAUX *"

%header {
  #include "jql.h"
  #include <errno.h>
  #include <stdbool.h>
  #include <setjmp.h>
  
  typedef struct _JPQDATA {
    int type;
    struct _JPQDATA *child;
    struct _JPQDATA *next;
  } JPQDATA;
  
  typedef struct _JPQAUX {
    int pos;
    int line;
    int col;
    iwrc rc;
    bool fatal_jmp_set;
    jmp_buf fatal_jmp;
    const char *buf;
  } JPQAUX;
}

%source {
  
  static int _jqp_get_char(JPQAUX *aux) {
    if (aux->rc || *(aux->buf + aux->pos) == '\0') {
      return -1;
    } else {
      char ch = *(aux->buf + aux->pos++);
      if (ch == '\n') {
        ++aux->line;
        aux->col = 0; 
      }
      ++aux->col;
      return ch;
    }
  }

  static void _jqp_error(JPQAUX *aux) {
    if (!aux->rc) {
      aux->rc = JQL_ERROR_QUERY_PARSE;
    }
    if (aux->fatal_jmp_set) {
      longjmp(aux->fatal_jmp, 1);
    } else {
      fprintf(stderr, "Query parsing error (JQL_ERROR_QUERY_PARSE)\n");
    }
  }
  
  static void *_jqp_malloc(JPQAUX *aux, size_t size) {
    void *ret = malloc(size);
    if (!ret) {
      aux->rc = iwrc_set_errno(IW_ERROR_ALLOC, errno);
      if (aux->fatal_jmp_set) {
        longjmp(aux->fatal_jmp, 1);
      } else {
        fprintf(stderr, "Memory allocation failed (IW_ERROR_ALLOC)\n");
        exit(1);
      }
    }
    return ret;
  }
  
  static void *_jqp_realloc(JPQAUX *aux, void *ptr, size_t size) {
    void *ret = realloc(ptr, size);
    if (!ret) {
      aux->rc = iwrc_set_errno(IW_ERROR_ALLOC, errno);
      if (aux->fatal_jmp_set) {
        longjmp(aux->fatal_jmp, 1);
      } else {
        fprintf(stderr, "Memory allocation failed (IW_ERROR_ALLOC)\n");
        exit(1);
      }
    }
    return ret;
  }
  
  #define PCC_GETCHAR(auxil) _jqp_get_char(auxil)
  #define PCC_ERROR(auxil) _jqp_error(auxil)
  #define PCC_MALLOC(auxil, size) _jqp_malloc(auxil, size)
  #define PCC_REALLOC(auxil, ptr, size) _jqp_realloc(auxil, ptr, size)
}

QUERY <- FILTER (__ FILTERJOIN __ FILTER)* (_ APPLY)? (_ PROJ)? _ EOF

##### Apply 

APPLY <- ('|' _ "apply" __ (OBJJ / ARRJ)) { fprintf(stderr, "A: '%s'\n", $0); }

##### Projection

PROJ <- '|' _ PROJCHAIN+

PROJCHAIN <- PROJNODES (__ PROJOIN _ PROJNODES)*

PROJNODES <- ("all" / PROJNODE PROJNODE*) { fprintf(stderr, "Z: '%s'\n", $0); }

PROJNODE <- '/' (PROJFIELDS / PROJPROP)

PROJFIELDS <- '{' _ PROJPROP (_ ',' _ PROJPROP)* _ '}'

PROJPROP <- STRN / PCHP+

PROJOIN <- ('+' / '-') { fprintf(stderr, "PJ: '%s'\n", $0); }

# Projection property char
PCHP <- '\\' '\\'
      / '\\' [bfnrt]
      / '\\' 'u' HEX HEX HEX HEX
      / !["/{},\t\n\r ] .

##### Query

FILTER <- FILTERPREFIX? (NODE NODE*)

FILTERPREFIX <- '@' [a-zA-Z0-9]+ { fprintf(stderr, "P: '%s'\n", $0); }

FILTERJOIN <- ("and" / "or" / "not") { fprintf(stderr, "J: '%s'\n", $0); }

# Node

NODE <- '/' (STRN / OPNODE / CHP+) { fprintf(stderr, "N: '%s'\n", $0); }

OPNODE <- '[' _ OPPAIR (__ OPJOIN __ OPPAIR)* _ ']'

OPPAIR <- OPLEFT _ OP _ OPRIGHT

OPLEFT <- STRN / NODELEFT / CHP+

NODELEFT <- '[' _ (STRN / CHP+) _ OP _ OPRIGHT _ ']'

OPRIGHT <- PLACEHOLDER / VALJ

PLACEHOLDER <- ':' ([a-zA-Z0-9]+ / '?') { fprintf(stderr, "P: '%s'\n", $0); }

# Node operation
OP <-  (  ("not" __)? ("like" / "in" / "re")
        / ">="
        / "<="
        / ('!' _)? '='
        / '>'
        / '<'
        / "not") { fprintf(stderr, "O: '%s'\n", $0); }

OPJOIN <- ("and" / "or")

# Node string
STRN <- '"' CHJ+ '"'


##### JSON 

OBJJ <- '{' _ (PAIRJ (_ ',' _ PAIRJ)* )? _ '}'

ARRJ <- '[' _ (VALJ (_ ',' _ VALJ)* )? _ ']'

PAIRJ <- STRJ _ ':' _ STRJ

VALJ <-   STRJ
        / NUMJ
        / OBJJ
        / ARRJ
        / "true"
        / "false"
        / "null"

# JSON string
STRJ <- '"' CHJ* '"'

# JSON char
CHJ <- '\\' '"'
      / '\\' '\\'
      / '\\' [bfnrt]
      / '\\' 'u' HEX HEX HEX HEX
      / !'"' .

# Property char
CHP <- '\\' '\\'
      / '\\' [bfnrt]
      / '\\' 'u' HEX HEX HEX HEX
      / ![/"[\]=><!\t\n\r ] .

NUMJ <- '-'? NUMI NUMF? NUME?

NUMI <- '0' / [1-9] [0-9]*

NUMF <- '.' [0-9]+

NUME <-  [eE] [+-]? DIGIT+

HEX <- [0-9A-Fa-f]

DIGIT <- [0-9]

_ <- [\t\n\r ]*

__ <- [\t\n\r ]+

EOF <- !.

%%
