--- The Lua binding of EJDB database.<br/>
-- <a href="http://ejdb.org">http://ejdb.org</a>

module("ejdb")

local ejdb = {}

--- Query/JSON builder is used to create EJDB queries or JSON objects with
-- preserverd keys order (Unlike lua tables).
-- @{Q} **can be used to construct BSON objects as well as queries.**
-- @class table
-- @name Q
--
-- Examples:
-- @usage Q("foo", "bar")
-- @usage Q("likes", "toys"):OrderBy("name asc", "age desc")
-- @usage Q("name", "Andy"):F("_id"):Eq("510f7fa91ad6270a00000000"):F("age"):Gt(20):Lt(40):F("score"):In({ 11, 22.12333, 1362835380447, db.toNull() }):Max(232)
-- @usage Q():Or(Q("foo", "bar"), Q("foo", "bar6")):OrderBy({ foo = 1 })
-- @see Q:F
-- @see Q:Eq
-- @see Q:ElemMatch
-- @see Q:Not
-- @see Q:Gt
-- @see Q:Gte
-- @see Q:Lt
-- @see Q:Lte
-- @see Q:Icase
-- @see Q:Begin
-- @see Q:In
-- @see Q:NotIn
-- @see Q:Bt
-- @see Q:StrAnd
-- @see Q:StrOr
-- @see Q:Inc
-- @see Q:Set
-- @see Q:AddToSet
-- @see Q:AddToSetAll
-- @see Q:Pull
-- @see Q:PullAll
-- @see Q:Upsert
-- @see Q:Upsert
-- @see Q:DropAll
-- @see Q:Join
-- @see Q:Or
-- @see Q:Skip
-- @see Q:Skip
-- @see Q:Max
-- @see Q:OrderBy
-- @see Q:Fields
-- @see Q:Fields
-- @see Q:NotFields
--
local Q = {}

---
-- Database itself.
-- @class table
-- @name DB
local DB = {}

---
-- Result set cursor object.
-- @class table
-- @name RS
-- Usage:
--    #res - length of result set
--    res[i] - BSON representations of object as lua string
--    res:object(i) - Lua table constructed from BSON data
--    res:field(i, <field name>) - Lua value of fetched BSON object
--    res() - Creates iterator for pairs (obj, idx)
--          where obj - Lua table constructed from BSON data
--                idx - Index of fetched object in the result set
--
-- Examples:
--    for i = 1, #res do
--      local ob = res:object(i)
--      ...
--    end
--
-- OR
--
--    for i = 1, #res do
--      res:field(i, "json field name")
--      ...
--    end
--
-- OR
--
--    for vobj, idx in res() do
--      -- vobj is a lua table representation of fetched json object
--      vobj["json field name"]
--      ...
--    end
-- @see RS:object
-- @see RS:field
local RS = {}

--- Opens EJDB database.
-- @usage local db = ejdb.open("foodb", "wrc")
-- @tparam string path Database main file
-- @tparam ?string mode Database open mode flags:<br/>
-- <code>`w`</code> Open as a writer <br/>
-- <code>`r`</code> Open as a reader <br/>
-- <code>`c`</code> Create db if it not exists <br/>
-- <code>`t`</code> Truncate existing db <br/>
-- <code>`s`</code> Sycn db after each transaction <br/>
-- Default open mode: <code>`rwcs`</code>
-- @return Database table
--
function ejdb.open(path, mode) end

--- Closes opened database.
function ejdb.close() end

--- Converts string OID into BSON oid table.
-- @tparam string val 24 hex chars BSON_OID
function ejdb.toOID(val) end

--- Converts os.time table (or number of seconds since epoch) into BSON_DATE.
-- @return BSON_DATE table.
-- @usage ejdb.toDate({ year = 2013, month = 1, day = 1, hour = 0, sec = 1 })
-- @usage ejdb.toDate(1363705285431)
function ejdb.toDate(val) end

--- Converts current time into BSON_DATE.
function ejdb.toDateNow() end

--- Builds BSON_REGEX value
-- @tparam string re Regular expression
-- @tparam ?string opts Regular expression flags
-- @return BSON_REGEX table value
function ejdb.toRegexp(re, opts) end

--- Converts lua string into BSON_BINDATA value
-- @return BSON_BINDATA table value
function ejdb.toBinData(val) end

--- Builds BSON_NULL value
-- @return BSON_NULL table value
function ejdb.toNull() end

--- Builds BSON_UNDEFINED value
-- @return BSON_UNDEFINED table value
function ejdb.toUndefined() end

--- Converts string OID into BSON oid table.
-- @see ejdb.toOID
function DB.toOID(val) end

--- Converts os.time table or number of secods integer into BSON_DATE.
-- @see ejdb.toDate
function DB.toDate(val) end

--- Converts current time into BSON_DATE.
-- @see ejdb.toDateNow
function DB.toDateNow() end

--- Builds BSON_REGEX value.
-- @see ejdb.toRegexp
function DB.toRegexp(re, opts) end

--- Converts lua string into BSON_BINDATA value.
-- @see ejdb.toBinData
function DB.toBinData(val) end

--- Builds BSON_NULL value.
-- @see ejdb.toNull
function DB.toNull() end

--- Builds BSON_UNDEFINED value .
-- @see ejdb.toUndefined
function DB.toUndefined() end

--- Save/update specified JSON objects in the collection.
-- If collection with `cname` does not exists it will be created.
-- Each persistent object has unique identifier (OID) placed in the `_id` property.
-- If a saved object does not have `_id` it will be autogenerated.
-- To identify and update object it should contains `_id` property.
-- @tparam string cname Name of collection.
-- @tparam table|Q obj represents JSON object.
-- @param ... If last argument is True a saved object will be merged with who's
-- already persisted in db.
-- @usage dQ:save("parrots2", {foo = "bar"})
-- @usage dQ:save("parrots2", Q("foo", "bar"), true) -- merge option is on
function DB:save(cname, obj, ...) end

--- Execute query on collection.
--
-- EJDB queries inspired by MongoDB (mongodb.org) and follows same philosophy.
--
-- Queries and query hints can be constructed by @{Q} query/json builder.
--    - Supported queries:
--    - Simple matching of String OR Number OR Array value:
--        -   {'fpath' : 'val', ...}
--    - $not Negate operation.
--        -   {'fpath' : {'$not' : val}} //Field not equal to val
--        -   {'fpath' : {'$not' : {'$begin' : prefix}}} //Field not begins with val
--    - $begin String starts with prefix
--        -   {'fpath' : {'$begin' : prefix}}
--    - $gt, $gte (>, >=) and $lt, $lte for number types:
--        -   {'fpath' : {'$gt' : number}, ...}
--    - $bt Between for number types:
--        -   {'fpath' : {'$bt' : [num1, num2]}}
--    - $in String OR Number OR Array val matches to value in specified array:
--        -   {'fpath' : {'$in' : [val1, val2, val3]}}
--    - $nin - Not IN
--    - $strand String tokens OR String array val matches all tokens in specified array:
--        -   {'fpath' : {'$strand' : [val1, val2, val3]}}
--    - $stror String tokens OR String array val matches any token in specified array:
--        -   {'fpath' : {'$stror' : [val1, val2, val3]}}
--    - $exists Field existence matching:
--        -   {'fpath' : {'$exists' : true|false}}
--    - $icase Case insensitive string matching:
--        -    {'fpath' : {'$icase' : 'val1'}} //icase matching
--              icase matching with '$in' operation:
--        -    {'name' : {'$icase' : {'$in' : ['HEllo', 'heLLo WorlD']}}}
--             For case insensitive matching you can create special type of string index.
--    - $elemMatch The $elemMatch operator matches more than one component within an array element.
--        -    { array: { $elemMatch: { value1 : 1, value2 : { $gt: 1 } } } }
--              Restriction: only one $elemMatch allowed in context of one array field.
--
-- - Queries can be used to update records:
--
--    $set Field set operation.
--        - {.., '$set' : {'field1' : val1, 'fieldN' : valN}}
--    $upsert Atomic upsert. If matching records are found it will be '$set' operation,
--            otherwise new record will be inserted
--            with fields specified by argment object.
--        - {.., '$upsert' : {'field1' : val1, 'fieldN' : valN}}
--    $inc Increment operation. Only number types are supported.
--        - {.., '$inc' : {'field1' : number, ...,  'field1' : number}
--    $dropall In-place record removal operation.
--        - {.., '$dropall' : true}
--    $addToSet Atomically adds value to the array only if its not in the array already.
--                If containing array is missing it will be created.
--        - {.., '$addToSet' : {'fpath' : val1, 'fpathN' : valN, ...}}
--    $addToSetAll Batch version if $addToSet
--        - {.., '$addToSetAll' : {'fpath' : [array of values to add], ...}}
--    $pull Atomically removes all occurrences of value from field, if field is an array.
--        - {.., '$pull' : {'fpath' : val1, 'fpathN' : valN, ...}}
--    $pullAll Batch version of $pull
--        - {.., '$pullAll' : {'fpath' : [array of values to remove], ...}}
--
-- - Collection joins supported in the following form:
--
--        {..., $do : {fpath : {$join : 'collectionname'}} }
--         Where 'fpath' value points to object's OIDs from 'collectionname'. Its value
--         can be OID, string representation of OID or array of this pointers.
--
--  **NOTE:** It is better to execute update queries with `$onlycount=true` hint flag
--        or use the special `update()` method to avoid unnecessarily data fetching.
--
--  **NOTE:** Negate operations: $not and $nin not using indexes
--        so they can be slow in comparison to other matching operations.
--
--  **NOTE:** Only one index can be used in search query operation.
--
--  **NOTE:** If callback is not provided this function will be synchronous.
--
--  **QUERY HINTS** specified by calling @{Q:Skip} @{Q:Max}, @{Q:OrderBy}, @{Q:Fields}:
--    - $max Maximum number in the result set
--    - $skip Number of skipped results in the result set
--    - $orderby Sorting order of query fields.
--    - $fields Set subset of fetched fields.
--        If field presented in $orderby clause it will be forced to include in resulting records.
--        Example:
--        hints:    {
--                    "$orderby" : { //ORDER BY field1 ASC, field2 DESC
--                        "field1" : 1,
--                        "field2" : -1
--                     },
--                    "$fields" : { //SELECT ONLY {_id, field1, field2}
--                        "field1" : 1,
--                        "field2" : 1
--                    }
--                  }
-- To traverse selected records cursor object is returned.
-- Cursor (res):
--    #res - length of result set
--    res[i] - BSON representations of object as lua string
--    res:object(i) - Lua table constructed from BSON data
--    res:field(i, <field name>) - Lua value of fetched BSON object
--    res() - Creates iterator for pairs (obj, idx)
--          where obj - Lua table constructed from BSON data
--                idx - Index of fetched object in the result set
--
-- Examples:
--    for i = 1, #res do
--      local ob = res:object(i)
--      ...
--    end
--
-- OR
--
--    for i = 1, #res do
--      res:field(i, "json field name")
--      ...
--    end
--
-- OR
--
--    for vobj, idx in res() do
--      -- vobj is a lua table representation of fetched json object
--      vobj["json field name"]
--      ...
--    end
--
--
-- @tparam string cname Name of collection
-- @tparam Q q JSON query object
-- @string flags Query control flags:
--    `c`: only count of matching records will be returned without placing records in result set.
--    `l`: return query execution log
-- @treturn RS result set, it will be `nil` if `c` flag presented in the control `flags`
-- @treturn number Count of matched/updated records
-- @treturn ?string Query execution log if `l` flag presented in the control `flags`
-- @usage db:find("mycoll", Q("foo", "bar")) => {"foo" : "bar"}
-- @usage db:find("mycoll", Q("foo", "bar"):Max(10)) -- Limit results up to 10 records
-- @usage db:find("parrots2", Q("likes", "toys"):OrderBy("name asc", "age desc"))
-- @usage db:find("parrots2", Q():F("likes"):Eq("toys"):OrderBy({ name = 1 }, { age = -1 }))
-- @see Q
--
function DB:find(cname, q, flags) end

--- Same as @{DB:find} but retrieves only first matching JSON object.
-- @tparam string cname Name of collection
-- @tparam Q q JSON query object
-- @treturn table Lua table constructed from matched BSON record or `nil` of record not found
-- @treturn number Count of matched/updated records
-- @treturn ?string Query execution log if `l` flag presented in the control `flags`

function DB:findOne(cname, q, ...) end

--- Convenient method to execute update queries.
-- @tparam string cname Name of collection
-- @tparam Q q JSON query object
-- @treturn number Count of matched/updated records
-- @treturn ?string Query execution log if `l` flag presented in the control `flags`

function DB:update(cname, q, ...) end

--- Convenient `count(*)` operation.
-- @tparam string cname Name of collection
-- @tparam Q q JSON query object
-- @treturn number Count of matched/updated records
-- @treturn ?string Query execution log if `l` flag presented in the control `flags`

function DB:count(cname, q, ...) end


--- Returns result set lua table object at specified position `i`
-- @tparam number i Position of record in the result set
-- @treturn table Resulting lua object constructed from BSON record.
function RS:object(i) end


--- Returns field value of lua object at specified position `i`
-- @tparam number i Position of record in the result set
-- @tparam string name JSON field name
-- @return Value of field
function RS:field(i, name) end

--- Length of result set.
function RS.__len() end


--- Set current field for the next operation during query building.
-- @string fname JSON field path
-- @usage Q:F("name"):Eq("andy"):F("age"):Gt(30) => {"name" : "andy", "age" : {"$gt" : 30}}
function Q:F(fname) end

--- Field equality restriction.
-- @param val any BSON value as Lua object including @{Q} instances.
-- All usage samples represent same thing: `{"fname" : fval}`
-- @usage Q():F("fname"):Eq(fval)
-- @usage Q("fname", fval)
-- @usage Q():F("fname", fval)
-- @return Self @{Q}
function Q:Eq(val) self:_setop(nil, val, nil, true) end

--- Element match construction.
-- - $elemMatch The $elemMatch operator matches more than one component within an array element.
-- -    { array: { $elemMatch: { value1 : 1, value2 : { $gt: 1 } } } }
-- Restriction: only one $elemMatch allowed in context of one array field.
-- @return Self @{Q}
function Q:ElemMatch(val) end

--- The $not negatiation for `val` block
-- @usage Q():Not(Q("foo", "bar")) => {"$not" : {"foo" : "bar"}}
-- @return Self @{Q}
function Q:Not(val) end

--- Greater than (val > arg)
-- @number val
-- @usage Q():F("age"):Gt(29) => {"age" : {"$gt" : 29}}
-- @return Self @{Q}
function Q:Gt(val) end

--- Greater than or equal (val >= arg)
-- @number val
-- @usage Q():F("age"):Gt(29) => {"age" : {"$gte" : 29}}
-- @return Self @{Q}
function Q:Gte(val) end

--- Lesser than (val < arg)
-- @number val
-- @usage Q():F("age"):Lt(29) => {"age" : {"$lt" : 29}}
-- @return Self @{Q}
function Q:Lt(val) end

--- Lesser than or equal (val <= arg)
-- @number val
-- @usage Q():F("age"):Lt(29) => {"age" : {"$lte" : 29}}
-- @return Self @{Q}
function Q:Lte(val) end

--- Case insensitive string matching
-- @tparam string|table|Q val
-- @usage Q():F("name"):Icase("aNdY") => {"name" : {"$icase" : "aNdY"}}
-- @usage Q():F("name"):Icase({[$in] = {"aNdY", "AnTon"}}) => {"name" : {"$icase" : {"$in" : ["aNdY", "AnTon"]}}}
-- @return Self @{Q}
function Q:Icase(val) end

--- String starts with prefix
-- @string val
-- @usage Q():F("fpath"):Begin("prefix") => {"fpath" : {"$begin" : "prefix"}}
-- @return Self @{Q}
function Q:Begin(val) end

--- Field value matched any value of specified in `val` table.
-- @tparam table val  Not empty lua array of values.
-- @usage Q():F("fpath"):In({"val1", "val2", "val3"}) => {"fpath" : {"$in" : ["val1", "val2", "val3"]}}
-- @return Self @{Q}
function Q:In(val) end

--- Negation of @{Q:In}
-- @see Q:In
-- @return Self @{Q}
function Q:NotIn(val) end

--- Between for number types
-- @number n1
-- @number n2
-- @usage Q():F("age"):Bt(10, 20) => {"age" : {"$bt" : [10, 20]}}
-- @return Self @{Q}
function Q:Bt(n1, n2) end

--- String tokens(or string array vals) matches **all** tokens in specified `val` array.
-- @tparam table val Array of tokens to match.
-- @usage Q():F("description"):StrAnd({"foo", "bar"}) -- descripton contains all tokens: 'foo' and 'bar'
-- @return Self @{Q}
function Q:StrAnd(val) end

--- String tokens(or string array vals) matches **any** token in specified array.
-- @tparam table val Array of tokens to match.
-- @usage Q():F("description"):StrOr({"foo", "bar"}) -- descripton contains all tokens: 'foo' or 'bar'
-- @return Self @{Q}
function Q:StrOr(val) end

--- Increment current field. Only number types are supported.
-- @number val
-- @usage Q():F("count"):Inc(1):F("age"):Inc(-20) => {"$inc" : {"count" : 1, "age" : -20}}
-- @return Self @{Q}
-- @see Q:F
function Q:Inc(val) end

--- Set fields to values.
-- @tparam table|Q val Table of fields to set
-- @usage Q():Set({age = 20, count = 1}) => {"$set" : {"age" : 20, count : 1}}
-- @return Self @{Q}
function Q:Set(val) end

--- Atomic upsert.
-- If matching records are found it will be `$set` operation,
-- otherwise new record will be inserted with fields specified by `val` table.
-- @tparam table|Q val Table of fields to set/insert
-- Insert {"foo" : "bar"} if this object does not exists:
-- @usage Q("foo","bar"):Upsert(Q("foo", "bar")) => {"foo" : "bar", "$upsert" : {"foo" : "bar"}}
-- @usage Q("foo","bar"):Upsert({foo ="bar"}) => {"foo" : "bar", "$upsert" : {"foo" : "bar"}}
-- @return Self @{Q}
function Q:Upsert(val) end

--- Atomically adds `val` to the `array field` only if `val` not in the array already.
-- If containing array is missing it will be created.
-- @param val Value to add
-- @usage Q():F("tags"):AddToSet("red") => {"$addToSet" : {"tags" : "red"}}
-- @return Self @{Q}
function Q:AddToSet(val) end

--- Atomically performs `set union` with values in `val` for specified array field.
-- @tparam table val Array of values to add
-- @usage Q():F("tags"):AddToSetAll({"red", "green"})
-- @see Q:F
-- @return Self @{Q}
function Q:AddToSetAll(val) end

--- Atomically removes all occurrences of `val` from field, if field is an array.
-- @param val Value to remove
-- @usage Q():F("tags"):Pull("red") => {"$pull" : {"tags" : "red"}}
-- @see Q:F
-- @return Self @{Q}
function Q:Pull(val) end

--- Atomically performs `set substraction` of values in `val` for specified array field.
-- @tparam table val Array of values to remove from array field
-- @usage Q():F("tags"):PullAll({"red", "green"}) => {"$pullAll" : {"tags" : ["red", "green"]}}
-- @see Q:F
-- @return Self @{Q}
function Q:PullAll(val) end

--- In-place record removal operation.
-- @usage db:update(Q():F("name", "andy"):DropAll()) -- Removes all records with name eq 'andy'
-- @return Self @{Q}
function Q:DropAll() end

--- Make <a href="https://github.com/Softmotions/ejdb/wiki/Collection-joins">collection join</a>
-- for select queries.
-- @string cname Name for joined collection
-- @string fpath Name of field with BSON OIDs of joined objects
-- @return Self @{Q}
function Q:Join(cname, fpath) end

--- Add *OR* joined query restrictions.
-- @tparam table|Q ... List of OR joined restrictions
-- @usage Q():Or(Q("name", "anton"), Q("name", "andy"))
--    Find records with "name" field eq "anton" or "andy"
-- @return Self @{Q}
function Q:Or(...) end

--- Sets number of skipped records in the result set.
-- @number val
-- @return Self @{Q}
function Q:Skip(val) end

--- Sets max number of records in the result set.
-- @number val
-- @return Self @{Q}
function Q:Max(val) end

--- Set sorting rules for query results.
-- tparam table|string
-- @usage Q:OrderBy("name asc", "age desc") => ORDER BY name ASC, age dESC
-- @usage Q:OrderBy({name = 1}, {age = -1}) => ORDER BY name ASC, age dESC
function Q:OrderBy(...) end

--- Sets fields to be included in resulting objects.
-- If field presented in $orderby clause it will be forced to include in resulting records.
-- @string ... Fields to be included in fetched objects.
-- @usage Q:Fields("name", "age")
-- @return Self @{Q}
function Q:Fields(...) end

--- Sets fields to be excluded from resulting objects.
-- @string ... Fields to be excluded from fetched objects.
-- @usage Q:NotFields("name", "description")
-- @return Self @{Q}
function Q:NotFields(...) end








