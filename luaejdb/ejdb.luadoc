--- The Lua binding of EJDB database.<br/>
-- <a href="http://ejdb.org">http://ejdb.org</a>

module("ejdb")

local ejdb = {}

--- Query/JSON builder is used to create EJDB queries or JSON objects with
-- preserverd keys order (Unlike lua tables).
-- @class table
-- @name Q
--
-- Examples:
-- @usage Q("foo", "bar")
-- @usage Q("likes", "toys"):OrderBy("name asc", "age desc")
-- @usage Q("name", "Andy"):F("_id"):Eq("510f7fa91ad6270a00000000"):F("age"):Gt(20):Lt(40):F("score"):In({ 11, 22.12333, 1362835380447, db.toNull() }):Max(232)
-- @usage Q():Or(Q("foo", "bar"), Q("foo", "bar6")):OrderBy({ foo = 1 })
-- @see Q:Eq
-- @see Q:ElemMatch
-- @see Q:Not
-- @see Q:Gt
-- @see Q:Gte
-- @see Q:Lt
-- @see Q:Lte
-- @see Q:Icase
-- @see Q:Begin
-- @see Q:In
-- @see Q:NotIn
-- @see Q:Bt
-- @see Q:StrAnd
-- @see Q:StrOr
-- @see Q:Inc
-- @see Q:Set
-- @see Q:AddToSet
-- @see Q:AddToSetAll
-- @see Q:Pull
-- @see Q:PullAll
-- @see Q:Upsert
-- @see Q:Upsert
-- @see Q:DropAll
-- @see Q:Do
-- @see Q:Or
-- @see Q:Skip
-- @see Q:Skip
-- @see Q:Max
-- @see Q:OrderBy
-- @see Q:Fields
-- @see Q:Fields
-- @see Q:NotFields
--
local Q = {}

---
-- Database itself.
-- @class table
-- @name DB
local DB = {}

--- Opens EJDB database.
-- @usage local db = ejdb.open("foodb", "wrc")
-- @param path {String} Database main file
-- @param mode {String?} Database open mode flags:<br/>
-- <code>`w`</code> Open as a writer <br/>
-- <code>`r`</code> Open as a reader <br/>
-- <code>`c`</code> Create db if it not exists <br/>
-- <code>`t`</code> Truncate existing db <br/>
-- <code>`s`</code> Sycn db after each transaction <br/>
-- Default open mode: <code>`rws`</code>
-- @return Database table
--
function ejdb.open(path, mode) end

--- Closes opened database.
function ejdb.close() end

--- Converts string OID into BSON oid table.
-- @param val {String} 24 hex chars BSON_OID
function ejdb.toOID(val) end

--- Converts os.time table (or number of seconds since epoch) into BSON_DATE.
-- @return BSON_DATE table.
-- @usage ejdb.toDate({ year = 2013, month = 1, day = 1, hour = 0, sec = 1 })
-- @usage ejdb.toDate(1363705285431)
function ejdb.toDate(val) end

--- Converts current time into BSON_DATE.
function ejdb.toDateNow() end

--- Builds BSON_REGEX value
-- @param re {String} Regular expression
-- @param opts {String} Regular expression flags
-- @return BSON_REGEX table value
function ejdb.toRegexp(re, opts) end

--- Converts lua string into BSON_BINDATA value
-- @return BSON_BINDATA table value
function ejdb.toBinData(val) end

--- Builds BSON_NULL value
-- @return BSON_NULL table value
function ejdb.toNull() end

--- Builds BSON_UNDEFINED value
-- @return BSON_UNDEFINED table value
function ejdb.toUndefined() end

--- Converts string OID into BSON oid table.
-- @see ejdb.toOID
function DB.toOID(val) end

--- Converts os.time table or number of secods integer into BSON_DATE.
-- @see ejdb.toDate
function DB.toDate(val) end

--- Converts current time into BSON_DATE.
-- @see ejdb.toDateNow
function DB.toDateNow() end

--- Builds BSON_REGEX value.
-- @see ejdb.toRegexp
function DB.toRegexp(re, opts) end

--- Converts lua string into BSON_BINDATA value.
-- @see ejdb.toBinData
function DB.toBinData(val) end

--- Builds BSON_NULL value.
-- @see ejdb.toNull
function DB.toNull() end

--- Builds BSON_UNDEFINED value .
-- @see ejdb.toUndefined
function DB.toUndefined() end

--- Save/update specified JSON objects in the collection.
-- If collection with `cname` does not exists it will be created.
-- Each persistent object has unique identifier (OID) placed in the `_id` property.
-- If a saved object does not have `_id` it will be autogenerated.
-- To identify and update object it should contains `_id` property.
-- @param cname {String} Name of collection.
-- @param obj Lua table or <a href="#Q">Q</a> represents JSON object.
-- @param ... If last argument is True a saved object will be merged with who's
-- already persisted in db.
-- @usage dQ:save("parrots2", {foo = "bar"})
-- @usage dQ:save("parrots2", Q("foo", "bar"), true) -- merge option is on
function DB:save(cname, obj, ...) end

--- Execute query on collection.
--
-- EJDB queries inspired by MongoDB (mongodb.org) and follows same philosophy.
-- - Supported queries:
--    - Simple matching of String OR Number OR Array value:
--        -   {'fpath' : 'val', ...}
--    - $not Negate operation.
--        -   {'fpath' : {'$not' : val}} //Field not equal to val
--        -   {'fpath' : {'$not' : {'$begin' : prefix}}} //Field not begins with val
--    - $begin String starts with prefix
--        -   {'fpath' : {'$begin' : prefix}}
--    - $gt, $gte (>, >=) and $lt, $lte for number types:
--        -   {'fpath' : {'$gt' : number}, ...}
--    - $bt Between for number types:
--        -   {'fpath' : {'$bt' : [num1, num2]}}
--    - $in String OR Number OR Array val matches to value in specified array:
--        -   {'fpath' : {'$in' : [val1, val2, val3]}}
--    - $nin - Not IN
--    - $strand String tokens OR String array val matches all tokens in specified array:
--        -   {'fpath' : {'$strand' : [val1, val2, val3]}}
--    - $stror String tokens OR String array val matches any token in specified array:
--        -   {'fpath' : {'$stror' : [val1, val2, val3]}}
--    - $exists Field existence matching:
--        -   {'fpath' : {'$exists' : true|false}}
--    - $icase Case insensitive string matching:
--        -    {'fpath' : {'$icase' : 'val1'}} //icase matching
--              icase matching with '$in' operation:
--        -    {'name' : {'$icase' : {'$in' : ['HEllo', 'heLLo WorlD']}}}
--             For case insensitive matching you can create special type of string index.
--    - $elemMatch The $elemMatch operator matches more than one component within an array element.
--        -    { array: { $elemMatch: { value1 : 1, value2 : { $gt: 1 } } } }
--              Restriction: only one $elemMatch allowed in context of one array field.
--
-- - Queries can be used to update records:
--
--    $set Field set operation.
--        - {.., '$set' : {'field1' : val1, 'fieldN' : valN}}
--    $upsert Atomic upsert. If matching records are found it will be '$set' operation,
--            otherwise new record will be inserted
--            with fields specified by argment object.
--        - {.., '$upsert' : {'field1' : val1, 'fieldN' : valN}}
--    $inc Increment operation. Only number types are supported.
--        - {.., '$inc' : {'field1' : number, ...,  'field1' : number}
--    $dropall In-place record removal operation.
--        - {.., '$dropall' : true}
--    $addToSet Atomically adds value to the array only if its not in the array already.
--                If containing array is missing it will be created.
--        - {.., '$addToSet' : {'fpath' : val1, 'fpathN' : valN, ...}}
--    $addToSetAll Batch version if $addToSet
--        - {.., '$addToSetAll' : {'fpath' : [array of values to add], ...}}
--    $pull Atomically removes all occurrences of value from field, if field is an array.
--        - {.., '$pull' : {'fpath' : val1, 'fpathN' : valN, ...}}
--    $pullAll Batch version of $pull
--        - {.., '$pullAll' : {'fpath' : [array of values to remove], ...}}
--
-- - Collection joins supported in the following form:
--
--        {..., $do : {fpath : {$join : 'collectionname'}} }
--         Where 'fpath' value points to object's OIDs from 'collectionname'. Its value
--         can be OID, string representation of OID or array of this pointers.
--
--  NOTE: It is better to execute update queries with `$onlycount=true` hint flag
--        or use the special `update()` method to avoid unnecessarily data fetching.
--  NOTE: Negate operations: $not and $nin not using indexes
--        so they can be slow in comparison to other matching operations.
--  NOTE: Only one index can be used in search query operation.
--  NOTE: If callback is not provided this function will be synchronous.
--
--  QUERY HINTS (specified by `hints` argument):
--    - $max Maximum number in the result set
--    - $skip Number of skipped results in the result set
--    - $orderby Sorting order of query fields.
--    - $onlycount true|false If `true` only count of matching records will be returned
--                            without placing records in result set.
--    - $fields Set subset of fetched fields.
--        If field presented in $orderby clause it will be forced to include in resulting records.
--        Example:
--        hints:    {
--                    "$orderby" : { //ORDER BY field1 ASC, field2 DESC
--                        "field1" : 1,
--                        "field2" : -1
--                     },
--                    "$fields" : { //SELECT ONLY {_id, field1, field2}
--                        "field1" : 1,
--                        "field2" : 1
--                    }
--                  }
-- To traverse selected records cursor object is returned.
-- Cursor (res):
--    #res - length of result set
--    res[i] - BSON representations of object as lua string
--    res:object(i) - Lua table constructed from BSON data
--    res:field(i, <field name>) - Lua value of fetched BSON object
--    res() - Creates iterator for pairs (obj, idx)
--          where obj - Lua table constructed from BSON data
--                idx - Index of fetched object in the result set
--
-- Examples:
--    for i = 1, #res do
--      local ob = res:object(i)
--      ...
--    end
--
-- OR
--
--    for i = 1, #res do
--      res:field(i, "json field name")
--      ...
--    end
--
-- OR
--
--    for vobj, idx in res() do
--      -- vobj is a lua table representation of fetched json object
--      vobj["json field name"]
--      ...
--    end
--
--
-- @param cname {String} Name of collection
-- @param q {table|Q} JSON query object
-- @see Q
--
function DB:find(cname, q, ...) end



--- Field eq restriction.
--    {fname : fval}
-- @usage Q():F("fname"):Eq(<fval>)
-- @usage Q("fname", <fval>)
function Q:Eq(val) self:_setop(nil, val, nil, true) end

--- Element match construction.
--    - $elemMatch The $elemMatch operator matches more than one component within an array element.
--      -    { array: { $elemMatch: { value1 : 1, value2 : { $gt: 1 } } } }
--        Restriction: only one $elemMatch allowed in context of one array field.
function Q:ElemMatch(val) end

--- The $not negatiation for `val` block
-- @usage Q():Not(Q("foo", "bar")) => {"$not" : {"foo" : "bar"}}
function Q:Not(val) end

--- Greater than (val > arg)
-- @usage Q():F("age"):Gt(29) => {"age" : {"$gt" : 29}}
function Q:Gt(val) end

--- Greater than or equal (val >= arg)
-- @usage Q():F("age"):Gt(29) => {"age" : {"$gte" : 29}}
function Q:Gte(val) end

--- Lesser than (val < arg)
-- @usage Q():F("age"):Lt(29) => {"age" : {"$lt" : 29}}
function Q:Lt(val) end

--- Lesser than or equal (val <= arg)
-- @usage Q():F("age"):Lt(29) => {"age" : {"$lte" : 29}}
function Q:Lte(val) end

function Q:Icase(val) end

function Q:Begin(val) end

function Q:In(val) end

function Q:NotIn(val) end

function Q:Bt(val) end

function Q:StrAnd(val)  end

function Q:StrOr(val) end

function Q:Inc(val) end

function Q:Set(val) end

function Q:AddToSet(val) end

function Q:AddToSetAll(val)  end

function Q:Pull(val) end

function Q:PullAll(val) end

function Q:Upsert(val) end

function Q:DropAll() end

function Q:Do(val) end

function Q:Or(...) end

function Q:Skip(val) end

function Q:Max(val) end

function Q:OrderBy(...) end

function Q:Fields(...) end

function Q:NotFields(...) end








